############################################################################
#
# shumway_tsa2/chap2.R
#
# ddantas 24/08/2022
#
############################################################################

source("const.R")
source("chap1.R")
source("utils.R")


############################################################################
#
# Load functions
#
############################################################################

load_mort <- function()
{
  mort = scan(paste(DATA, "cmort.dat", sep=""))
  temp  = scan(paste(DATA, "temp.dat", sep=""))
  part  = scan(paste(DATA, "part.dat", sep=""))

  result = cbind(mort, temp, part)
  return(result)
}

load_detrend_globtemp <- function()
{
  temp = scan(paste(DATA, "globtemp.dat", sep=""))
  x = temp[45:142]
  x = ts(x, start=1900, frequency=1)
  dx = temp[44:142]
  dx = diff(dx)

  result = cbind(x, dx)
  return(result)
}

load_varve <- function()
{
  data = scan(paste(DATA, "varve.dat", sep=""))
  return(data) 
}

############################################################################
#
# Definitions
#
############################################################################


############################################################################
#
# Figures and examples
#
############################################################################

# Figure 2.1: Global temperature deviations shown in Figure 1.2 with fitted linear trend line.
fig201 <- function()
{
  x = load_globtemp()
  s = start(x)[1]
  t = seq(s, s+length(x)-1)
  fit = lm(x~t)
  plot.ts(x, xlab="Year", ylab="Temp. deviation")
  abline(fit)
}

# Figure 2.2: Average daily cardiovascular mortality, temperature and particulate pollution in Los Angeles County.
fig202 <- function()
{
  mat = load_mort()
  plot.ts(mat)
}

# Figure 2.3: Scatterplot matrix showing plausible relatins between mortality, temperature and pollution. 
fig203 <- function()
{
  mat = load_mort()
  pairs(mat)
}

# Example 2.2: Pollution, temperature and mortality.
ex202 <- function()
{
  mat = load_mort()
  mort = mat[,"mort"]
  temp = mat[,"temp"]
  part = mat[,"part"]
  
  temp = temp - mean(temp)
  temp2 = temp^2
  t = 1:length(mort)
  fit1 = lm(mort~t)
  fit2 = lm(mort~t + temp)
  fit3 = lm(mort~t + temp + temp2)
  fit4 = lm(mort~t + temp + temp2 + part)

  return(list(fit1, fit2, fit3, fit4))
}

# Figure 2.4: Detrended and differenced global temperature series.
fig204 <- function()
{
  mat = load_detrend_globtemp()
  x  = mat[,"x"]
  dx = mat[,"dx"]  
  
  s = start(x)[1]
  t = seq(s, s+length(x)-1)
  fit = lm(x~t)
  par(mfrow=c(2, 1))
  plot(t, fit$resid, xlab="Year", ylab="Detrended gtemp", type="l")
  plot(t, dx, xlab="Year", ylab="Detrended gtemp", type="l")  
}

# Figure 2.5: Sample ACFs of the global temperature, and of the detrended and differenced series. 
fig205 <- function()
{
  mat = load_detrend_globtemp()
  x  = mat[,"x"]
  dx = mat[,"dx"]  
  
  s = start(x)[1]
  t = seq(s, s+length(x)-1)
  fit = lm(x~t)
  par(mfrow=c(3, 1))
  lag = 50
  acf(x, lag)
  acf(fit$resid, lag)
  acf(dx, lag)
}

# Figure 2.6: Glacial varve thickness from Massachusetts for n = 634 years and log transformed thickness.
fig206 <- function()
{
  data = load_varve()

  par(mfrow=c(2, 1))
  plot.ts(data)
  result = log(data)
  plot.ts(result)
}

# Figure 2.7: Scatterplot matrix relating current to past SOI values at lags 1 to 12.
fig207 <- function()
{
  mat = load_soi()
  soi = mat[,"soi"]

  lag.plot(soi, lags=12, layout=c(3,4), fiag=F)
}

# Figure 2.8: Scatterplot matrix of the Recruitment series on the vertical axis against the SOI series on the horizontal axis at lags 0 to 15.
fig208 <- function()
{
  mat = load_soi()
  soi = mat[,"soi"]
  rec = mat[,"rec"]

  par(mfrow=c(4,4), mar=c(2.5, 4, 4, 1))
  for(h in 0:15)
  {
    plot(lag(soi, -h), rec, main=paste("SOI(t-", h, ")", sep=""),
         ylab="Rec(t)", xlab="")
  }
}

# Figure 2.9: Data generated by Equation 2.35 with the fitted line superimposed.
fig209 <- function()
{
  set.seed(154)
  w = rnorm(500, 0, 5)
  t = 1:500
  c = 2*cos(2*pi*t/50 + .6*pi)
  cw = c + w

  a = cos(2*pi*t/50)
  b = sin(2*pi*t/50)
  fit = lm(cw~a + b)

  par(mfrow=c(3,1))
  ts.plot(cbind(cw, c), col=c(1,2))
  plot.ts(a)
  plot.ts(b)

  A = sqrt(fit$coefficients[2]^2 + fit$coefficients[3]^2)
  phia = acos(fit$coefficients[2] / A) / pi
  phib = asin(-fit$coefficients[3] / A) / pi
  print(fit)
  print(A)
  print(phia)
  print(phib)
}

# Figure 2.10: The scaled periodogram (Equation 2.42) of the 500 observations generated by Equation 2.35.
fig210 <- function()
{
  set.seed(154)
  w = rnorm(500, 0, 5)
  t = 1:500
  c = 2*cos(2*pi*t/50 + .6*pi)
  cw = c + w

  I = abs(fft(cw) / sqrt(500))^2
  P = 4/500 * I
  f = 0:250/500
  plot(f, P[1:251], type="l", xlab="frequency", ylab="")
  abline(v=seq(0, 0.5, 0.02), lty="dotted")
}

# Figure 2.11: Data generated by Equation 2.47 with cosines oscilating at various frequencies superimposed.
fig211 <- function()
{
  set.seed(154)
  n = 100
  w = rnorm(n, 0, 1)
  t = 1:n
  c = 2*cos(2*pi*t*(2/100))
  cw = c + w

  par(mfrow=c(3,1))
  s1 = 2*cos(2*pi*t*(1/100))
  main = paste("One cycle j/n=1/100 correlation=", cor(cw,s1), sep="")
  ts.plot(cbind(cw, s1), lty=c(1, 2), main=main)

  s2 = 2*cos(2*pi*t*(2/100))
  main = paste("Two cycles j/n=2/100 correlation=", cor(cw,s2), sep="")
  ts.plot(cbind(cw, s2), lty=c(1, 2), main=main)

  s3 = 2*cos(2*pi*t*(3/100))
  main = paste("Three cycles j/n=3/100 correlation=", cor(cw,s3), sep="")
  ts.plot(cbind(cw, s3), lty=c(1, 2), main=main)
}

# Figure 2.12: The weekly cardiovascular mortality series of Example 2.2 smoothed using a 5-week and a 53-week moving average.
fig212 <- function()
{
  mat = load_mort()
  mort = mat[,"mort"]
  ma5  = filter(mort, sides=2, rep(1,5)/5)
  ma53 = filter(mort, sides=2, rep(1,53)/53)

  plot(mort, col="gray", xlab="week", ylab="mortality")
  lines(ma5)
  lines(ma53)
}

# Figure 2.13: The weekly cardiovascular mortality series with a cubic trend and cubic trend plus periodic regression.
fig213 <- function()
{
  mat = load_mort()
  mort = mat[,"mort"]
  t = 1:length(mort)
  t2 = t^2
  t3 = t^3
  c = cos(2*pi*t / 52)
  s = sin(2*pi*t / 52)
  fit1 = lm(mort ~ t + t2 + t3)
  fit2 = lm(mort ~ t + t2 + t3 + c + s)

  plot(t, mort, col="gray", xlab="week", ylab="mortality")
  lines(fit1$fit)
  lines(fit2$fit)
}

# Figure 2.14: Kernel smoothers of the mortality data.
fig214 <- function()
{
  mat = load_mort()
  mort = mat[,"mort"]
  t = 1:length(mort)

  plot(t, mort, col="gray", xlab="week", ylab="mortality")
  lines(ksmooth(t, mort, "normal", bandwidth=5))
  lines(ksmooth(t, mort, "normal", bandwidth=104))
}

# Figure 2.15: Nearest neighbor (supsmu) and locally weighted least squares (lowess) smoothers of the mortality data.
fig215 <- function()
{
  mat = load_mort()
  mort = mat[,"mort"]
  t = 1:length(mort)

  par(mfrow=c(2,1))
  plot(t, mort, col="gray", xlab="week", ylab="mortality", main="nearest neighbor")
  lines(supsmu(t, mort, span=0.5))
  lines(supsmu(t, mort, span=0.01))
  plot(t, mort, col="gray", xlab="week", ylab="mortality", main="lowess")
  lines(lowess(t, mort, 0.02))
  lines(lowess(t, mort, 2/3))
}

# Figure 2.16: Smoothing splines fit to the mortality data.
fig216 <- function()
{
  mat = load_mort()
  mort = mat[,"mort"]
  t = 1:length(mort)

  plot(t, mort, col="gray", xlab="week", ylab="mortality", main="splines")
  lines(smooth.spline(t, mort, spar=0.0000001))
  lines(smooth.spline(t, mort, spar=1))
}

# Figure 2.17: Smoothers of mortality as a function of temperature using lowess and smoothing splines.
fig217 <- function()
{
  mat = load_mort()
  temp = mat[,"temp"]
  mort = mat[,"mort"]

  par(mfrow=c(2,1))
  plot(temp, mort, col="gray", xlab="temperature", ylab="mortality", main="lowess")
  lines(lowess(temp, mort))
  plot(temp, mort, col="gray", xlab="temperature", ylab="mortality", main="splines")
  lines(lowess(temp, mort))
}


############################################################################
#
# Problems
#
############################################################################

prob201 <- function()
{
  jj = load_jj()
  t = 1:length(jj)
  x = log(jj)
  q1 = rep(c(1,0,0,0), 21)
  q2 = rep(c(0,1,0,0), 21)
  q3 = rep(c(0,0,1,0), 21)
  q4 = rep(c(0,0,0,1), 21)
  fit1 = lm(x~0 + t + q1 + q2 + q3 + q4)
  fit2 = lm(x~    t + q1 + q2 + q3 + q4)

  par(mfrow=c(2,1))
  plot(t, x, col="gray", xlab="temperature", ylab="mortality", main="without intercept")
  lines(fit1$fit)
  lines(fit1$residuals)
  plot(t, x, col="gray", xlab="temperature", ylab="mortality", main="with intercept")
  lines(fit2$fit)
  lines(fit2$residuals)
}

prob202 <- function()
{
  mat = load_mort()
  mort = mat[,"mort"]
  temp = mat[,"temp"]
  part = mat[,"part"]

  part_m4 = shift(part, 4)
  temp = temp - mean(temp)
  temp2 = temp^2
  t = ts(1:length(mort))
  mat = ts.intersect(mort, t, temp, temp2, part, part_m4)

  pairs(mat[,c(1, 3, 5, 6)], upper.panel=panel.cor, diag.panel=panel.hist)

  fit1 = lm(mort~t)
  fit2 = lm(mort~t + temp)
  fit3 = lm(mort~t + temp + temp2)
  fit4 = lm(mort~t + temp + temp2 + part)
  fit5 = lm(mort~t + temp + temp2 + part_m4)
  fit6 = lm(mort~t + temp + temp2 + part + part_m4)

  for (lag in seq(-10, 10))
  {
    cat(lag, cor(mort, shift(part, lag)), "\n", sep="\t")
  }

  return(list(fit1, fit2, fit3, fit4, fit5, fit6))
}

prob203 <- function()
{
  set.seed(154)
  len = 500
  w = rnorm(len, 0, 1)
  t = seq(len)
  x = cumsum(w)
  d = 0.1
  wd = w + d
  xd = cumsum(wd)
  fit = lm(xd~t)

  plot.ts(xd, ylim=c(-10, 60))
  lines(x)
  lines(d * (1:500), lty="dashed")
  lines(fit$fit, lty=3)
}
